<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Biological Network Diagram Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            padding: 30px;
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2rem;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-style: italic;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 12px 25px;
            background: #4A90E2;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        button:hover {
            background: #3A7BC8;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        #canvas-container {
            background: #F5F5F5;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
        }

        .info {
            margin-top: 20px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 8px;
            text-align: center;
            color: #666;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-box {
            width: 30px;
            height: 20px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .legend-box.central {
            background: #4A90E2;
        }

        .legend-box.regular {
            background: #D3D3D3;
        }

        .legend-box.edge {
            background: linear-gradient(to right, #CCCCCC, #CCCCCC);
            height: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ§¬ Biological Network Diagram Generator</h1>
        <p class="subtitle">Clean, scientific visualization of protein interaction networks</p>

        <div class="controls">
            <button onclick="generateNetwork()">Generate New Network</button>
            <button onclick="downloadCanvas()">Download Image</button>
        </div>

        <div id="canvas-container">
            <canvas id="networkCanvas" width="1400" height="1000"></canvas>
        </div>

        <div class="info">
            <p id="networkInfo">Click "Generate New Network" to create a biological network diagram</p>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-box central"></div>
                    <span>Central Hub Node</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box regular"></div>
                    <span>Network Nodes</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box edge"></div>
                    <span>Connections</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('networkCanvas');
        const ctx = canvas.getContext('2d');

        class BiologicalNetworkGenerator {
            constructor(canvas, ctx) {
                this.canvas = canvas;
                this.ctx = ctx;
                this.nodes = [];
                this.edges = [];
                this.clusters = [];
            }

            generateNetwork(numNodes = 15) {
                this.nodes = [];
                this.edges = [];
                this.clusters = [];

                // Generate nodes with random positions
                for (let i = 0; i < numNodes; i++) {
                    this.nodes.push({
                        id: i,
                        x: Math.random() * 0.8 + 0.1,
                        y: Math.random() * 0.8 + 0.1,
                        vx: 0,
                        vy: 0,
                        degree: 0
                    });
                }

                // Create scale-free network (BarabÃ¡si-Albert model)
                // Start with a small connected graph
                for (let i = 0; i < Math.min(3, numNodes); i++) {
                    for (let j = i + 1; j < Math.min(3, numNodes); j++) {
                        this.addEdge(i, j);
                    }
                }

                // Preferential attachment
                for (let i = 3; i < numNodes; i++) {
                    let m = 2; // Number of edges to add
                    let targets = this.selectTargetsByDegree(i, m);
                    targets.forEach(target => {
                        this.addEdge(i, target);
                    });
                }

                // Add some random edges for visual interest
                for (let i = 0; i < 5; i++) {
                    let u = Math.floor(Math.random() * numNodes);
                    let v = Math.floor(Math.random() * numNodes);
                    if (u !== v && !this.hasEdge(u, v)) {
                        this.addEdge(u, v);
                    }
                }

                // Identify clusters using simple community detection
                this.identifyClusters();

                // Run force-directed layout
                this.forceDirectedLayout(100);

                // Find central node (highest degree)
                this.centralNode = 0;
                let maxDegree = 0;
                this.nodes.forEach(node => {
                    if (node.degree > maxDegree) {
                        maxDegree = node.degree;
                        this.centralNode = node.id;
                    }
                });

                return {
                    nodes: this.nodes.length,
                    edges: this.edges.length,
                    central: this.centralNode
                };
            }

            addEdge(u, v) {
                if (!this.hasEdge(u, v)) {
                    this.edges.push({ from: u, to: v });
                    this.nodes[u].degree++;
                    this.nodes[v].degree++;
                }
            }

            hasEdge(u, v) {
                return this.edges.some(e =>
                    (e.from === u && e.to === v) || (e.from === v && e.to === u)
                );
            }

            selectTargetsByDegree(newNode, m) {
                let targets = new Set();
                let totalDegree = this.nodes.slice(0, newNode).reduce((sum, n) => sum + (n.degree || 1), 0);

                while (targets.size < m && targets.size < newNode) {
                    let rand = Math.random() * totalDegree;
                    let cumulative = 0;

                    for (let i = 0; i < newNode; i++) {
                        cumulative += this.nodes[i].degree || 1;
                        if (rand <= cumulative && !targets.has(i)) {
                            targets.add(i);
                            break;
                        }
                    }
                }

                return Array.from(targets);
            }

            identifyClusters() {
                // Simple clustering based on connected components
                let visited = new Set();
                this.clusters = [];

                this.nodes.forEach(node => {
                    if (!visited.has(node.id)) {
                        let cluster = this.dfs(node.id, visited);
                        if (cluster.length > 2) {
                            this.clusters.push(cluster);
                        }
                    }
                });
            }

            dfs(nodeId, visited) {
                let cluster = [nodeId];
                visited.add(nodeId);

                let neighbors = this.edges
                    .filter(e => e.from === nodeId || e.to === nodeId)
                    .map(e => e.from === nodeId ? e.to : e.from)
                    .filter(n => !visited.has(n));

                neighbors.forEach(n => {
                    if (Math.random() > 0.5) { // Probabilistic clustering
                        cluster.push(...this.dfs(n, visited));
                    }
                });

                return cluster;
            }

            forceDirectedLayout(iterations) {
                const width = this.canvas.width;
                const height = this.canvas.height;

                for (let iter = 0; iter < iterations; iter++) {
                    // Reset forces
                    this.nodes.forEach(node => {
                        node.vx = 0;
                        node.vy = 0;
                    });

                    // Repulsive forces (all nodes repel each other)
                    for (let i = 0; i < this.nodes.length; i++) {
                        for (let j = i + 1; j < this.nodes.length; j++) {
                            let dx = this.nodes[j].x - this.nodes[i].x;
                            let dy = this.nodes[j].y - this.nodes[i].y;
                            let dist = Math.sqrt(dx * dx + dy * dy) + 0.01;
                            let force = 0.01 / (dist * dist);

                            this.nodes[i].vx -= force * dx / dist;
                            this.nodes[i].vy -= force * dy / dist;
                            this.nodes[j].vx += force * dx / dist;
                            this.nodes[j].vy += force * dy / dist;
                        }
                    }

                    // Attractive forces (connected nodes attract)
                    this.edges.forEach(edge => {
                        let from = this.nodes[edge.from];
                        let to = this.nodes[edge.to];
                        let dx = to.x - from.x;
                        let dy = to.y - from.y;
                        let dist = Math.sqrt(dx * dx + dy * dy);
                        let force = dist * 0.05;

                        from.vx += force * dx;
                        from.vy += force * dy;
                        to.vx -= force * dx;
                        to.vy -= force * dy;
                    });

                    // Update positions
                    this.nodes.forEach(node => {
                        node.x += node.vx * 0.1;
                        node.y += node.vy * 0.1;

                        // Keep nodes within bounds
                        node.x = Math.max(0.1, Math.min(0.9, node.x));
                        node.y = Math.max(0.1, Math.min(0.9, node.y));
                    });
                }
            }

            draw() {
                const width = this.canvas.width;
                const height = this.canvas.height;

                // Clear canvas with light grey background
                this.ctx.fillStyle = '#F5F5F5';
                this.ctx.fillRect(0, 0, width, height);

                // Draw cluster backgrounds
                this.clusters.forEach(cluster => {
                    if (cluster.length > 2) {
                        let points = cluster.map(id => ({
                            x: this.nodes[id].x * width,
                            y: this.nodes[id].y * height
                        }));

                        // Calculate convex hull (simplified)
                        let minX = Math.min(...points.map(p => p.x)) - 80;
                        let maxX = Math.max(...points.map(p => p.x)) + 80;
                        let minY = Math.min(...points.map(p => p.y)) - 60;
                        let maxY = Math.max(...points.map(p => p.y)) + 60;

                        this.ctx.fillStyle = 'rgba(232, 232, 232, 0.3)';
                        this.ctx.beginPath();
                        this.ctx.ellipse(
                            (minX + maxX) / 2,
                            (minY + maxY) / 2,
                            (maxX - minX) / 2,
                            (maxY - minY) / 2,
                            0, 0, Math.PI * 2
                        );
                        this.ctx.fill();
                    }
                });

                // Draw edges with curved lines
                this.edges.forEach(edge => {
                    let from = this.nodes[edge.from];
                    let to = this.nodes[edge.to];

                    let x1 = from.x * width;
                    let y1 = from.y * height;
                    let x2 = to.x * width;
                    let y2 = to.y * height;

                    // Control point for curve
                    let midX = (x1 + x2) / 2;
                    let midY = (y1 + y2) / 2;
                    let dx = x2 - x1;
                    let dy = y2 - y1;
                    let ctrlX = midX - dy * 0.1;
                    let ctrlY = midY + dx * 0.1;

                    this.ctx.strokeStyle = 'rgba(204, 204, 204, 0.6)';
                    this.ctx.lineWidth = 1.5;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.quadraticCurveTo(ctrlX, ctrlY, x2, y2);
                    this.ctx.stroke();
                });

                // Draw nodes
                this.nodes.forEach(node => {
                    let x = node.x * width;
                    let y = node.y * height;
                    let w = 90;
                    let h = 55;
                    let r = 10;

                    let isCentral = node.id === this.centralNode;

                    // Shadow
                    this.ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                    this.ctx.shadowBlur = 8;
                    this.ctx.shadowOffsetX = 2;
                    this.ctx.shadowOffsetY = 2;

                    // Node rectangle
                    this.ctx.fillStyle = isCentral ? '#4A90E2' : '#D3D3D3';
                    this.ctx.strokeStyle = isCentral ? '#3A7BC8' : '#B8B8B8';
                    this.ctx.lineWidth = 1.5;

                    this.ctx.beginPath();
                    this.ctx.moveTo(x - w/2 + r, y - h/2);
                    this.ctx.lineTo(x + w/2 - r, y - h/2);
                    this.ctx.quadraticCurveTo(x + w/2, y - h/2, x + w/2, y - h/2 + r);
                    this.ctx.lineTo(x + w/2, y + h/2 - r);
                    this.ctx.quadraticCurveTo(x + w/2, y + h/2, x + w/2 - r, y + h/2);
                    this.ctx.lineTo(x - w/2 + r, y + h/2);
                    this.ctx.quadraticCurveTo(x - w/2, y + h/2, x - w/2, y + h/2 - r);
                    this.ctx.lineTo(x - w/2, y - h/2 + r);
                    this.ctx.quadraticCurveTo(x - w/2, y - h/2, x - w/2 + r, y - h/2);
                    this.ctx.closePath();
                    this.ctx.fill();
                    this.ctx.stroke();

                    // Reset shadow
                    this.ctx.shadowColor = 'transparent';

                    // Node label
                    this.ctx.fillStyle = isCentral ? 'white' : '#333333';
                    this.ctx.font = isCentral ? 'bold 13px Arial' : '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(`Node ${node.id}`, x, y);
                });

                // Title
                this.ctx.fillStyle = '#333333';
                this.ctx.font = 'bold 24px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Biological Network Diagram', width / 2, 40);

                // Subtitle
                this.ctx.font = 'italic 14px Arial';
                this.ctx.fillStyle = '#666666';
                this.ctx.fillText(
                    `${this.nodes.length} nodes, ${this.edges.length} edges | Blue node: Central hub`,
                    width / 2,
                    height - 30
                );
            }
        }

        let generator = new BiologicalNetworkGenerator(canvas, ctx);

        function generateNetwork() {
            const numNodes = 12 + Math.floor(Math.random() * 8); // 12-20 nodes
            const stats = generator.generateNetwork(numNodes);
            generator.draw();

            document.getElementById('networkInfo').textContent =
                `Network generated: ${stats.nodes} nodes, ${stats.edges} connections, central hub: Node ${stats.central}`;
        }

        function downloadCanvas() {
            const link = document.createElement('a');
            link.download = 'biological_network.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        // Generate initial network
        window.onload = () => {
            generateNetwork();
        };
    </script>
</body>
</html>
